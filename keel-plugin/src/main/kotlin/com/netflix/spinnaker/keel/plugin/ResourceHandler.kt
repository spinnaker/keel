package com.netflix.spinnaker.keel.plugin

import com.fasterxml.jackson.databind.ObjectMapper
import com.netflix.spinnaker.keel.api.ApiVersion
import com.netflix.spinnaker.keel.api.Resource
import com.netflix.spinnaker.keel.api.ResourceKind
import com.netflix.spinnaker.keel.api.ResourceId
import com.netflix.spinnaker.keel.api.ResourceSpec
import com.netflix.spinnaker.keel.api.SubmittedResource
import com.netflix.spinnaker.keel.api.id
import com.netflix.spinnaker.keel.api.randomUID
import com.netflix.spinnaker.keel.diff.ResourceDiff
import com.netflix.spinnaker.keel.events.Task
import org.slf4j.Logger

/**
 * @param S the spec type.
 * @param R the resolved model type.
 *
 * If those two are the same, use [SimpleResourceHandler] instead.
 */
interface ResourceHandler<S : ResourceSpec, R : Any> : KeelPlugin {

  val log: Logger

  val objectMapper: ObjectMapper

  val resolvers: List<Resolver<*>>

  val apiVersion: ApiVersion

  /**
   * Maps the kind to the implementation type.
   */
  val supportedKind: Pair<ResourceKind, Class<S>>

  /**
   * Validates the resource spec and generates a metadata header.
   *
   * Implementors should not generally need to override this method.
   *
   * @return a hydrated `Resource` with a name generated by convention, an `id`,  `uid`, etc.
   */
  fun normalize(resource: SubmittedResource<S>): Resource<S> {
    val metadata = resource.metadata + mapOf(
      "id" to resource.id.toString(),
      "uid" to randomUID().toString(),
      "application" to resource.spec.application
    )
    return Resource(
      apiVersion = resource.apiVersion,
      kind = resource.kind,
      metadata = metadata,
      spec = resource.spec
    )
  }

  /**
   * Applies any defaults / opinions to the resource as it is resolved into its [desired] state.
   *
   * @return [resource] or a copy of [resource] that may have been changed in order to set default
   * values or apply opinions.
   */
  fun applyResolvers(resource: Resource<S>): Resource<S> =
    resolvers
      .filter { it.handles(resource.apiVersion, resource.kind) }
      .filterIsInstance<Resolver<S>>()
      .fold(resource) { r, resolver ->
        log.debug("Applying ${resolver.javaClass} to ${r.id}")
        resolver.normalize(r)
      }

  /**
   * Resolve the resource spec into the desired state. This may involve looking up referenced
   * resources, etc.
   *
   * The value returned by this method is used as the basis of the diff (with the result of
   * [current] in order to decide whether to call [create]/[update]/[upsert].
   *
   * Implementations of this method should not actuate any changes.
   */
  suspend fun desired(resource: Resource<S>): R

  /**
   * Return the current _actual_ representation of what [resource] looks like in the cloud.
   * The entire desired state is passed so that implementations can use whatever identifying
   * information they need to look up the resource.
   *
   * The value returned by this method is used as the basis of the diff (with the result of
   * [desired] in order to decide whether to call [create]/[update]/[upsert].
   *
   * Implementations of this method should not actuate any changes.
   */
  suspend fun current(resource: Resource<S>): R?

  /**
   * Create a resource so that it matches the desired state represented by [resource].
   *
   * By default this just delegates to [upsert].
   *
   * Implement this method and [update] if you need to handle create and update in different ways.
   * Otherwise just implement [upsert].
   *
   * @return a list of tasks launched to actuate the resource.
   */
  suspend fun create(
    resource: Resource<S>,
    resourceDiff: ResourceDiff<R>
  ): List<Task> =
    upsert(resource, resourceDiff)

  /**
   * Update a resource so that it matches the desired state represented by [resource].
   *
   * By default this just delegates to [upsert].
   *
   * Implement this method and [create] if you need to handle create and update in different ways.
   * Otherwise just implement [upsert].
   *
   * @return a list of tasks launched to actuate the resource.
   */
  suspend fun update(
    resource: Resource<S>,
    resourceDiff: ResourceDiff<R>
  ): List<Task> =
    upsert(resource, resourceDiff)

  /**
   * Create or update a resource so that it matches the desired state represented by [resource].
   *
   * You don't need to implement this method if you are implementing [create] and [update]
   * individually.
   *
   * @return a list of tasks launched to actuate the resource.
   */
  suspend fun upsert(
    resource: Resource<S>,
    resourceDiff: ResourceDiff<R>
  ): List<Task> {
    TODO("Not implemented")
  }

  /**
   * Delete a resource as the desired state is that it should no longer exist.
   */
  suspend fun delete(resource: Resource<S>)

  /**
   * @return `true` if this plugin is still busy running a previous actuation, `false` otherwise.
   */
  suspend fun actuationInProgress(id: ResourceId): Boolean = false
}

/**
 * Searches a list of `ResourceHandler`s and returns the first that supports [apiVersion] and
 * [kind].
 *
 * @throws UnsupportedKind if no appropriate handlers are found in the list.
 */
fun Collection<ResourceHandler<*, *>>.supporting(
  apiVersion: ApiVersion,
  kind: String
): ResourceHandler<*, *> =
  find { it.apiVersion == apiVersion && it.supportedKind.first.singular == kind }
    ?: throw UnsupportedKind(apiVersion, kind)

class UnsupportedKind(apiVersion: ApiVersion, kind: String) :
  IllegalStateException("No resource handler supporting \"$kind\" in \"$apiVersion\" is available")
